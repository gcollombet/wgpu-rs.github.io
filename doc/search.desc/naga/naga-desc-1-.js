searchState.loadedDescShard("naga", 1, "Returns whether or not a char is a word part (Unicode …\nReturns whether or not a char is a word start (Unicode …\nThe byte offset of the end of the most recently returned …\nReturn the next non-whitespace token from <code>self</code>.\nReturn the next non-whitespace token from <code>self</code>.\nReturn the next non-whitespace token from <code>self</code>, with a …\nParses a generic scalar type, for example <code>&lt;f32&gt;</code>.\nParses a generic scalar type, for example <code>&lt;f32&gt;</code>.\nIf the next token matches it is skipped and true is …\nThe full original source code.\nAbstract Float (IEEE-754 binary64)\nAbstract Int (-2^63 ≤ i &lt; 2^63)\nConcrete f32\nConcrete f64\nConcrete i32\nConcrete i64\nWhen using this type assume no Abstract Int/Float for now\nConcrete u32\nConcrete u64\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKeywords for WGSL (WebGPU Shading Language).\nAn unsigned 32-bit value known not to be <code>u32::MAX</code>.\nReturns the argument unchanged.\nConstruct a <code>NonMaxU32</code> whose value is <code>index</code>.\nReturn the value of <code>self</code> as a <code>u32</code>.\nCalls <code>U::from(self)</code>.\nConstruct a <code>NonMaxU32</code> whose value is <code>n</code>, if possible.\nConstruct a <code>NonMaxU32</code> whose value is <code>n</code>.\nA newtype struct where its only valid values are powers of …\nA context for evaluating constant expressions.\nHelper class to emit expressions\nA type stored in the associated arena.\nIf const is also implemented as const\nHelper processor that derives the sizes of all types.\nThis processor assigns names to all the things in a module …\nSize and alignment information for a type.\nThe result of computing an expression’s type.\nA free-floating <code>TypeInner</code>, representing a type that may …\nWhich language’s evaluation rules we should follow.\nThe module’s constant arena.\nEnsure that the given block has return statements at the …\nTry to evaluate the expression in the <code>arena</code> using its …\nTry to evaluate the expression in <code>self.global_expressions</code> …\nTry to evaluate the expression in the <code>arena</code> using its …\nTracks the constness of expressions residing in …\nThe arena to which we are contributing expressions.\nReturn an iterator over the individual components …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDefinitions for index bounds checking.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLayouts for types in an arena.\nThe module’s override arena.\nMethods on <code>TypeInner</code>, <code>Scalar</code>, and <code>ScalarKind</code>.\nThe module’s type arena.\nThe last numeric suffix used for each base name. Zero …\nMaps to <code>Literal::AbstractFloat</code>\nMaps to <code>Literal::AbstractFloat</code>\nMaps to <code>Literal::AbstractFloat</code>\nMaps to <code>Literal::AbstractInt</code>\nMaps to <code>Literal::AbstractInt</code>\nA subset of <code>Literal</code>s intended to be used for implementing …\nconst-expressions will be evaluated and inserted in the …\nconst-expressions will be evaluated and inserted in the …\nA context for evaluating constant expressions.\nMaps to <code>Literal::F32</code>\nMaps to <code>Literal::F32</code>\nMaps to <code>Literal::F32</code>\nA subset of <code>Literal</code>s intended to be used for implementing …\nMaps to <code>Literal::I32</code>\nMaps to <code>Literal::I32</code>\nMaps to <code>Literal::I32</code>\nMaps to <code>Literal::I64</code>\nIf const is also implemented as const\nconst-expressions will be evaluated and inserted in the …\nconst-expressions will be evaluated and inserted in the …\nconst-expressions will be evaluated and inserted in the …\nA subset of <code>Literal</code>s intended to be used for implementing …\nA subset of <code>Literal</code>s intended to be used for implementing …\nTrait for conversions of abstract values to concrete types.\nMaps to <code>Literal::U32</code>\nMaps to <code>Literal::U32</code>\nMaps to <code>Literal::U64</code>\nWhich language’s evaluation rules we should follow.\nConvert the scalar components of <code>expr</code> to <code>target</code>.\nConvert the scalar leaves of  <code>expr</code> to <code>target</code>, handling …\nAttempts to evaluate multiple <code>exprs</code> as a combined …\nA convenience macro for using the same RHS for each …\nAttempts to evaluate multiple <code>exprs</code> as a combined <code>Float</code> to …\nA convenience macro for using the same RHS for each <code>Float</code> …\nAttempts to evaluate multiple <code>exprs</code> as a combined <code>Scalar</code> …\nA convenience macro for using the same RHS for each <code>Scalar</code> …\nAttempts to evaluate multiple <code>exprs</code> as a combined <code>Signed</code> …\nA convenience macro for using the same RHS for each <code>Signed</code> …\nThe module’s constant arena.\nDeep copy <code>expr</code> from <code>expressions</code> into <code>self.expressions</code>.\nLower <code>ZeroValue</code> expressions to <code>Literal</code> and <code>Compose</code> …\nLower <code>ZeroValue</code> and <code>Splat</code> expressions to <code>Literal</code> and …\nLower <code>ZeroValue</code> expressions to <code>Literal</code> and <code>Compose</code> …\nTracks the constness of expressions residing in …\nThe arena to which we are contributing expressions.\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nForces the the expression to not be const\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobal constant expressions\nReturns <code>true</code> if the inner WGSL/GLSL restrictions are …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the <code>Self::expressions</code> arena the global module …\nReturns <code>true</code> if naga can also evaluate expression as const\nThe module’s override arena.\nSplat <code>value</code> to <code>size</code>, without using <code>Splat</code> expressions.\nTry to evaluate <code>expr</code> at compile time.\nConvert an abstract literal <code>value</code> to <code>Self</code>.\nThe module’s type arena.\nA macro that allows dollar signs (<code>$</code>) to be emitted by …\nHelper class to emit expressions\nPolicies for injecting bounds checks during code …\nHow should code generated by Naga do bounds checks?\nThe number of elements is determined at runtime.\nAn index that may be statically known, or may need to be …\nThe number of elements in an indexable type.\nValues of this type always have the given number of …\nOut-of-bounds reads return zero, and writes have no effect.\nReplace out-of-bounds indexes with some arbitrary …\nNaga adds no checks to indexing operations. Generate the …\nDetermine whether <code>index</code> is statically known to be in …\nHow should the generated code handle binding array indexes …\nHow should the generated code handle array, vector, or …\nDetermine which policy applies to <code>base</code>.\nReturn <code>true</code> if any of <code>self</code>’s policies are <code>policy</code>.\nBuild a set of expressions used as indices, to cache in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHow should the generated code handle image texel loads …\nHow should the generated code handle array, vector, or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a <code>GuardedIndex::Known</code> from a <code>GuardedIndex::Expression</code> …\nA newtype struct where its only valid values are powers of …\nHelper processor that derives the sizes of all types.\nSize and alignment information for a type.\nRemove all entries from this <code>Layouter</code>, retaining storage.\nPanics\nReturns whether or not <code>n</code> is a multiple of this alignment.\nLayouts for types in an arena.\nRound <code>n</code> up to the nearest alignment boundary.\nProduce the stride as if this type is a base of an array.\nExtend this <code>Layouter</code> with layouts for any new entries in …\nA string wrapper type with an ascii case insensitive Eq …\nThis processor assigns names to all the things in a module …\nReturn a new identifier based on <code>label_raw</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEnter a local namespace for things like structs.\nReturn a form of <code>string</code> suitable for use as the base of an …\nThe last numeric suffix used for each base name. Zero …\nEnsure that the given block has return statements at the …\nA type stored in the associated arena.\nThe result of computing an expression’s type.\nA free-floating <code>TypeInner</code>, representing a type that may …\nDetermine the type of <code>expr</code>.\nInitialize a resolve context from the module.\nConvenience trait for <code>Error</code> to be able to apply spans to …\nConvenience trait for <code>Result</code>, adding a …\nThe returned output type.\nThe returned output type.\nA human-readable representation for a span, tailored for …\nA source code span, used for error reporting.\nA source code span together with “context”, a …\nTrait abstracting over getting a span from an <code>Arena</code> or a …\nWrapper class for <code>Error</code>, augmenting it with a list of …\nConvert inner error into another type. Joins span …\nEmits a summary of the error to standard error stream.\nEmits a summary of the error to standard error stream.\nEmits a summary of the error to a string.\nEmits a summary of the error to a string.\nReverse of <code>Self::new</code>, discards span information and …\nConvert inner error using <code>From</code>.\nCheck whether <code>self</code> was defined or is a default/unknown span\nLength in code units (in bytes) of the span.\n1-based line number.\n1-based column in code units (in bytes) of the start of …\nReturn a <code>SourceLocation</code> for this span in the provided …\nReturn a <code>SourceLocation</code> for our first span, if we have one.\nCreates a new <code>Span</code> from a range of byte indices\nCreate a new <code>WithSpan</code> from an <code>Error</code>, containing no spans.\n0-based Offset in code units (in bytes) of the start of …\nIterator over stored <code>SpanContext</code>s.\nModifies <code>self</code> to contain the smallest <code>Span</code> possible that …\nConverts <code>self</code> to a range if the span is not unknown\nReturns the smallest <code>Span</code> possible that contains all the …\nReturns a new <code>Span</code> starting at <code>self</code> and ending at <code>other</code>\nAdd a <code>SpanContext</code>.\nAdd a <code>Handle</code> from either <code>Arena</code> or <code>UniqueArena</code>, borrowing …\nSee <code>WithSpan::new</code>.\nAdd a new span with description.\nSee <code>WithSpan::with_context</code>.\nSee <code>WithSpan::with_handle</code>.\nSee <code>WithSpan::with_span</code>.\nreductions, scans\nballot, broadcast\nElect, Barrier\nGroup, binding, and location attributes.\nStatements and blocks of them.\nSupport for <code>BuiltIn::ClipDistance</code>.\nConstants.\nUniformity of control flow for operations that require it.\nSupport for arrayed cube textures.\nSupport for <code>BuiltIn::CullDistance</code>.\nAllowed IR capabilities.\nSupport for generating two sources for blending from …\nSupport for <code>early_depth_test</code>.\nExpressions.\nInformation about an expression in a function body.\nFloat values with width = 8.\nIndicates how a global variable is used.\nSupport for <code>BuiltIn::SampleIndex</code> and <code>Sampling::Sample</code>.\nSupport for <code>BuiltIn::ViewIndex</code>.\nSupport for <code>BuiltIn::PrimitiveIndex</code>.\nSupport for <code>AddressSpace::PushConstant</code>.\nSupport for ray queries returning vertex position\nSupport for ray queries and acceleration structures.\nSupport for non-uniform indexing of sampled textures and …\nSupport for non-uniform indexing of samplers.\nSupport for <code>AtomicFunction::Add</code>, <code>AtomicFunction::Sub</code>, and …\nSupport for 64-bit signed and unsigned integers.\nSupport for all atomic operations on 64-bit integers.\nSupport for <code>AtomicFunction::Min</code> and <code>AtomicFunction::Max</code> on …\nshuffle, shuffle xor\nshuffle up, down\nSupport for 16-bit normalized storage texture formats.\nSupport for non-uniform indexing of storage texture arrays.\nHost-shareable structure layouts.\nSupport for subgroup operations. Implies support for …\nSupport for subgroup barriers.\nSupport for subgroup operations in the vertex stage.\nValidation flags.\nSupported subgroup operations\nSupport for atomic operations on images.\nSupport for atomic operations on 64-bit images.\nFlags associated with <code>Type</code>s by <code>Validator</code>.\nSupport for non-uniform indexing of uniform buffer arrays.\nUniform control flow characteristics.\nKinds of expressions that require uniform control flow.\nAny, All\nValidation flags.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nModule analyzer.\nThe global variable into which this expression produces a …\nSet of shader stages where calling this function is valid.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe leaf of all module-wide diagnostic filter rules tree …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIndicates that the function is using dual source blending.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nInformation about each expression in this function’s …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nValidation flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nHow this function and its callees use this module’s …\nImplementation of <code>Validator::validate_module_handles</code>.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nFunction may kill the invocation.\nA checklist of expressions that must be visited by a …\nConstruct a new validator instance.\nA child expression with non-uniform result.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nPopulates <code>self.const_expression_types</code>\nBuilds the <code>FunctionInfo</code> based on the function, and …\nThe number of statements and other expressions using this …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIf this expression requires uniform control flow, store …\nReset the validator internals\nAll (texture, sampler) pairs that may be used together in …\nAll pairs of (texture, sampler) globals that may be used …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe type of this expression.\nWhether this expression is uniform, and why.\nUniformity characteristics.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nCheck the given module to be valid.\nValidate all handles that occur in <code>expression</code>, whose …\nValidates that all handles within <code>module</code> are:\nCheck the given module to be valid.\nValidate all handles that occur in <code>ty</code>, whose handle is …\nAtomic operations will be performed on the variable.\nInformation about an expression in a function body.\nUniformity characteristics of a function.\nIndicates how a global variable is used.\nControl flow may be killed. Anything after <code>Statement::Kill</code> …\nControl flow may return from the function, which makes all …\nNo value.\nThe information about the data is queried.\nData will be read from the variable.\nSome value of type <code>T</code>.\nUniform control flow characteristics.\nDisruptor of the uniform control flow.\nKinds of expressions that require uniform control flow.\nData will be written to the variable.\nRecord a use of <code>expr</code>, and indicate which global variable it\nRecord a use of <code>expr</code> for its value.\nRecord a use of <code>expr</code> of the sort given by <code>global_use</code>.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nThe global variable into which this expression produces a …\nSet of shader stages where calling this function is valid.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe leaf of all module-wide diagnostic filter rules tree …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIndicates that the function is using dual source blending.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nReturns a disruptor based on the stored exit flags, if any.\nInformation about each expression in this function’s …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nValidation flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nHow this function and its callees use this module’s …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nFunction may kill the invocation.\nA child expression with non-uniform result.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nAnalyzes the uniformity requirements of a block (as a …\nInherit information from a called function.\nCompute the <code>ExpressionInfo</code> for <code>handle</code>.\nThe number of statements and other expressions using this …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIf this expression requires uniform control flow, store …\nAll (texture, sampler) pairs that may be used together in …\nAll pairs of (texture, sampler) globals that may be used …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe type of this expression.\nWhether this expression is uniform, and why.\nUniformity characteristics.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe control can break.\nThe control can continue.\nThe control can return out of this block.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis type can be passed as a function argument.\nA WGSL constructible type.\nThe data can be copied around.\nThe set of types with a fixed size at shader-creation time …\nCan be used for data variables.\nContains the error value\nCan be used for host-shareable structures.\nCan be be used for user-defined IO between pipeline stages.\nContains the success value\nThe data type has a size known by pipeline creation time.\nFlags associated with <code>Type</code>s by <code>Validator</code>.\nGet a flags value with all known bits set.\nGet the underlying bits value.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nDetermine whether a pointer in <code>space</code> can be passed as an …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.")