<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `naga/src/back/hlsl/mod.rs`."><title>mod.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="naga" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../../static.files/storage-59e33391.js"></script><script defer src="../../../../static.files/src-script-56102188.js"></script><script defer src="../../../../src-files.js"></script><script defer src="../../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">naga/back/hlsl/</div>mod.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers">
<a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
<a href="#487" id="487">487</a>
<a href="#488" id="488">488</a>
<a href="#489" id="489">489</a>
<a href="#490" id="490">490</a>
<a href="#491" id="491">491</a>
<a href="#492" id="492">492</a>
<a href="#493" id="493">493</a>
<a href="#494" id="494">494</a>
<a href="#495" id="495">495</a>
<a href="#496" id="496">496</a>
<a href="#497" id="497">497</a>
<a href="#498" id="498">498</a>
<a href="#499" id="499">499</a>
<a href="#500" id="500">500</a>
<a href="#501" id="501">501</a>
<a href="#502" id="502">502</a>
<a href="#503" id="503">503</a>
<a href="#504" id="504">504</a>
<a href="#505" id="505">505</a>
<a href="#506" id="506">506</a>
<a href="#507" id="507">507</a>
<a href="#508" id="508">508</a>
<a href="#509" id="509">509</a>
<a href="#510" id="510">510</a>
<a href="#511" id="511">511</a>
<a href="#512" id="512">512</a>
<a href="#513" id="513">513</a>
<a href="#514" id="514">514</a>
<a href="#515" id="515">515</a>
<a href="#516" id="516">516</a>
<a href="#517" id="517">517</a>
<a href="#518" id="518">518</a>
<a href="#519" id="519">519</a>
<a href="#520" id="520">520</a>
<a href="#521" id="521">521</a>
<a href="#522" id="522">522</a>
<a href="#523" id="523">523</a>
<a href="#524" id="524">524</a>
<a href="#525" id="525">525</a>
<a href="#526" id="526">526</a>
<a href="#527" id="527">527</a>
<a href="#528" id="528">528</a>
<a href="#529" id="529">529</a>
<a href="#530" id="530">530</a>
<a href="#531" id="531">531</a>
<a href="#532" id="532">532</a>
<a href="#533" id="533">533</a>
<a href="#534" id="534">534</a>
<a href="#535" id="535">535</a>
<a href="#536" id="536">536</a>
<a href="#537" id="537">537</a>
<a href="#538" id="538">538</a>
<a href="#539" id="539">539</a>
<a href="#540" id="540">540</a>
<a href="#541" id="541">541</a></pre></div><pre class="rust"><code><span class="doccomment">/*!
Backend for [HLSL][hlsl] (High-Level Shading Language).

# Supported shader model versions:
- 5.0
- 5.1
- 6.0

# Layout of values in `uniform` buffers

WGSL's ["Internal Layout of Values"][ilov] rules specify how each WGSL
type should be stored in `uniform` and `storage` buffers. The HLSL we
generate must access values in that form, even when it is not what
HLSL would use normally.

The rules described here only apply to WGSL `uniform` variables. WGSL
`storage` buffers are translated as HLSL `ByteAddressBuffers`, for
which we generate `Load` and `Store` method calls with explicit byte
offsets. WGSL pipeline inputs must be scalars or vectors; they cannot
be matrices, which is where the interesting problems arise.

## Row- and column-major ordering for matrices

WGSL specifies that matrices in uniform buffers are stored in
column-major order. This matches HLSL's default, so one might expect
things to be straightforward. Unfortunately, WGSL and HLSL disagree on
what indexing a matrix means: in WGSL, `m[i]` retrieves the `i`'th
*column* of `m`, whereas in HLSL it retrieves the `i`'th *row*. We
want to avoid translating `m[i]` into some complicated reassembly of a
vector from individually fetched components, so this is a problem.

However, with a bit of trickery, it is possible to use HLSL's `m[i]`
as the translation of WGSL's `m[i]`:

- We declare all matrices in uniform buffers in HLSL with the
  `row_major` qualifier, and transpose the row and column counts: a
  WGSL `mat3x4&lt;f32&gt;`, say, becomes an HLSL `row_major float3x4`. (Note
  that WGSL and HLSL type names put the row and column in reverse
  order.) Since the HLSL type is the transpose of how WebGPU directs
  the user to store the data, HLSL will load all matrices transposed.

- Since matrices are transposed, an HLSL indexing expression retrieves
  the "columns" of the intended WGSL value, as desired.

- For vector-matrix multiplication, since `mul(transpose(m), v)` is
  equivalent to `mul(v, m)` (note the reversal of the arguments), and
  `mul(v, transpose(m))` is equivalent to `mul(m, v)`, we can
  translate WGSL `m * v` and `v * m` to HLSL by simply reversing the
  arguments to `mul`.

## Padding in two-row matrices

An HLSL `row_major floatKx2` matrix has padding between its rows that
the WGSL `matKx2&lt;f32&gt;` matrix it represents does not. HLSL stores all
matrix rows [aligned on 16-byte boundaries][16bb], whereas WGSL says
that the columns of a `matKx2&lt;f32&gt;` need only be [aligned as required
for `vec2&lt;f32&gt;`][ilov], which is [eight-byte alignment][8bb].

To compensate for this, any time a `matKx2&lt;f32&gt;` appears in a WGSL
`uniform` variable, whether directly as the variable's type or as part
of a struct/array, we actually emit `K` separate `float2` members, and
assemble/disassemble the matrix from its columns (in WGSL; rows in
HLSL) upon load and store.

For example, the following WGSL struct type:

```ignore
struct Baz {
        m: mat3x2&lt;f32&gt;,
}
```

is rendered as the HLSL struct type:

```ignore
struct Baz {
    float2 m_0; float2 m_1; float2 m_2;
};
```

The `wrapped_struct_matrix` functions in `help.rs` generate HLSL
helper functions to access such members, converting between the stored
form and the HLSL matrix types appropriately. For example, for reading
the member `m` of the `Baz` struct above, we emit:

```ignore
float3x2 GetMatmOnBaz(Baz obj) {
    return float3x2(obj.m_0, obj.m_1, obj.m_2);
}
```

We also emit an analogous `Set` function, as well as functions for
accessing individual columns by dynamic index.

## Sampler Handling

Due to limitations in how sampler heaps work in D3D12, we need to access samplers
through a layer of indirection. Instead of directly binding samplers, we bind the entire
sampler heap as both a standard and a comparison sampler heap. We then use a sampler
index buffer for each bind group. This buffer is accessed in the shader to get the actual
sampler index within the heap. See the wgpu_hal dx12 backend documentation for more
information.

[hlsl]: https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl
[ilov]: https://gpuweb.github.io/gpuweb/wgsl/#internal-value-layout
[16bb]: https://github.com/microsoft/DirectXShaderCompiler/wiki/Buffer-Packing#constant-buffer-packing
[8bb]: https://gpuweb.github.io/gpuweb/wgsl/#alignment-and-size
*/

</span><span class="kw">mod </span>conv;
<span class="kw">mod </span>help;
<span class="kw">mod </span>keywords;
<span class="kw">mod </span>ray;
<span class="kw">mod </span>storage;
<span class="kw">mod </span>writer;

<span class="kw">use </span>std::fmt::Error <span class="kw">as </span>FmtError;
<span class="kw">use </span>thiserror::Error;

<span class="kw">use crate</span>::{back, proc};

<span class="attr">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash)]
#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
</span><span class="kw">pub struct </span>BindTarget {
    <span class="kw">pub </span>space: u8,
    <span class="doccomment">/// For regular bindings this is the register number.
    ///
    /// For sampler bindings, this is the index to use into the bind group's sampler index buffer.
    </span><span class="kw">pub </span>register: u32,
    <span class="doccomment">/// If the binding is an unsized binding array, this overrides the size.
    </span><span class="kw">pub </span>binding_array_size: <span class="prelude-ty">Option</span>&lt;u32&gt;,
    <span class="doccomment">/// This is the index in the buffer at [`Options::dynamic_storage_buffer_offsets_targets`].
    </span><span class="kw">pub </span>dynamic_storage_buffer_offsets_index: <span class="prelude-ty">Option</span>&lt;u32&gt;,
    <span class="doccomment">/// This is a hint that we need to restrict indexing of vectors, matrices and arrays.
    ///
    /// If [`Options::restrict_indexing`] is also `true`, we will restrict indexing.
    </span><span class="attr">#[cfg_attr(any(feature = <span class="string">"serialize"</span>, feature = <span class="string">"deserialize"</span>), serde(default))]
    </span><span class="kw">pub </span>restrict_indexing: bool,
}

<span class="attr">#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]
#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
</span><span class="doccomment">/// BindTarget for dynamic storage buffer offsets
</span><span class="kw">pub struct </span>OffsetsBindTarget {
    <span class="kw">pub </span>space: u8,
    <span class="kw">pub </span>register: u32,
    <span class="kw">pub </span>size: u32,
}

<span class="attr">#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
</span><span class="kw">struct </span>BindingMapSerialization {
    resource_binding: <span class="kw">crate</span>::ResourceBinding,
    bind_target: BindTarget,
}

<span class="attr">#[cfg(feature = <span class="string">"deserialize"</span>)]
</span><span class="kw">fn </span>deserialize_binding_map&lt;<span class="lifetime">'de</span>, D&gt;(deserializer: D) -&gt; <span class="prelude-ty">Result</span>&lt;BindingMap, D::Error&gt;
<span class="kw">where
    </span>D: serde::Deserializer&lt;<span class="lifetime">'de</span>&gt;,
{
    <span class="kw">use </span>serde::Deserialize;

    <span class="kw">let </span>vec = Vec::&lt;BindingMapSerialization&gt;::deserialize(deserializer)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>map = BindingMap::default();
    <span class="kw">for </span>item <span class="kw">in </span>vec {
        map.insert(item.resource_binding, item.bind_target);
    }
    <span class="prelude-val">Ok</span>(map)
}

<span class="comment">// Using `BTreeMap` instead of `HashMap` so that we can hash itself.
</span><span class="kw">pub type </span>BindingMap = std::collections::BTreeMap&lt;<span class="kw">crate</span>::ResourceBinding, BindTarget&gt;;

<span class="doccomment">/// A HLSL shader model version.
</span><span class="attr">#[allow(non_snake_case, non_camel_case_types)]
#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, PartialOrd)]
#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
</span><span class="kw">pub enum </span>ShaderModel {
    V5_0,
    V5_1,
    V6_0,
    V6_1,
    V6_2,
    V6_3,
    V6_4,
    V6_5,
    V6_6,
    V6_7,
}

<span class="kw">impl </span>ShaderModel {
    <span class="kw">pub const fn </span>to_str(<span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str {
        <span class="kw">match </span><span class="self">self </span>{
            <span class="self">Self</span>::V5_0 =&gt; <span class="string">"5_0"</span>,
            <span class="self">Self</span>::V5_1 =&gt; <span class="string">"5_1"</span>,
            <span class="self">Self</span>::V6_0 =&gt; <span class="string">"6_0"</span>,
            <span class="self">Self</span>::V6_1 =&gt; <span class="string">"6_1"</span>,
            <span class="self">Self</span>::V6_2 =&gt; <span class="string">"6_2"</span>,
            <span class="self">Self</span>::V6_3 =&gt; <span class="string">"6_3"</span>,
            <span class="self">Self</span>::V6_4 =&gt; <span class="string">"6_4"</span>,
            <span class="self">Self</span>::V6_5 =&gt; <span class="string">"6_5"</span>,
            <span class="self">Self</span>::V6_6 =&gt; <span class="string">"6_6"</span>,
            <span class="self">Self</span>::V6_7 =&gt; <span class="string">"6_7"</span>,
        }
    }
}

<span class="kw">impl </span><span class="kw">crate</span>::ShaderStage {
    <span class="kw">pub const fn </span>to_hlsl_str(<span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str {
        <span class="kw">match </span><span class="self">self </span>{
            <span class="self">Self</span>::Vertex =&gt; <span class="string">"vs"</span>,
            <span class="self">Self</span>::Fragment =&gt; <span class="string">"ps"</span>,
            <span class="self">Self</span>::Compute =&gt; <span class="string">"cs"</span>,
        }
    }
}

<span class="kw">impl </span><span class="kw">crate</span>::ImageDimension {
    <span class="kw">const fn </span>to_hlsl_str(<span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">'static </span>str {
        <span class="kw">match </span><span class="self">self </span>{
            <span class="self">Self</span>::D1 =&gt; <span class="string">"1D"</span>,
            <span class="self">Self</span>::D2 =&gt; <span class="string">"2D"</span>,
            <span class="self">Self</span>::D3 =&gt; <span class="string">"3D"</span>,
            <span class="self">Self</span>::Cube =&gt; <span class="string">"Cube"</span>,
        }
    }
}

<span class="attr">#[derive(Clone, Copy, Debug, Hash, Eq, Ord, PartialEq, PartialOrd)]
#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
</span><span class="kw">pub struct </span>SamplerIndexBufferKey {
    <span class="kw">pub </span>group: u32,
}

<span class="attr">#[derive(Clone, Debug, Hash, PartialEq, Eq)]
#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, serde(default))]
</span><span class="kw">pub struct </span>SamplerHeapBindTargets {
    <span class="kw">pub </span>standard_samplers: BindTarget,
    <span class="kw">pub </span>comparison_samplers: BindTarget,
}

<span class="kw">impl </span>Default <span class="kw">for </span>SamplerHeapBindTargets {
    <span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{
            standard_samplers: BindTarget {
                space: <span class="number">0</span>,
                register: <span class="number">0</span>,
                binding_array_size: <span class="prelude-val">None</span>,
                dynamic_storage_buffer_offsets_index: <span class="prelude-val">None</span>,
                restrict_indexing: <span class="bool-val">false</span>,
            },
            comparison_samplers: BindTarget {
                space: <span class="number">1</span>,
                register: <span class="number">0</span>,
                binding_array_size: <span class="prelude-val">None</span>,
                dynamic_storage_buffer_offsets_index: <span class="prelude-val">None</span>,
                restrict_indexing: <span class="bool-val">false</span>,
            },
        }
    }
}

<span class="attr">#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
</span><span class="kw">struct </span>SamplerIndexBufferBindingSerialization {
    group: u32,
    bind_target: BindTarget,
}

<span class="attr">#[cfg(feature = <span class="string">"deserialize"</span>)]
</span><span class="kw">fn </span>deserialize_sampler_index_buffer_bindings&lt;<span class="lifetime">'de</span>, D&gt;(
    deserializer: D,
) -&gt; <span class="prelude-ty">Result</span>&lt;SamplerIndexBufferBindingMap, D::Error&gt;
<span class="kw">where
    </span>D: serde::Deserializer&lt;<span class="lifetime">'de</span>&gt;,
{
    <span class="kw">use </span>serde::Deserialize;

    <span class="kw">let </span>vec = Vec::&lt;SamplerIndexBufferBindingSerialization&gt;::deserialize(deserializer)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>map = SamplerIndexBufferBindingMap::default();
    <span class="kw">for </span>item <span class="kw">in </span>vec {
        map.insert(
            SamplerIndexBufferKey { group: item.group },
            item.bind_target,
        );
    }
    <span class="prelude-val">Ok</span>(map)
}

<span class="comment">// We use a BTreeMap here so that we can hash it.
</span><span class="kw">pub type </span>SamplerIndexBufferBindingMap =
    std::collections::BTreeMap&lt;SamplerIndexBufferKey, BindTarget&gt;;

<span class="attr">#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
</span><span class="kw">struct </span>DynamicStorageBufferOffsetTargetSerialization {
    index: u32,
    bind_target: OffsetsBindTarget,
}

<span class="attr">#[cfg(feature = <span class="string">"deserialize"</span>)]
</span><span class="kw">fn </span>deserialize_storage_buffer_offsets&lt;<span class="lifetime">'de</span>, D&gt;(
    deserializer: D,
) -&gt; <span class="prelude-ty">Result</span>&lt;DynamicStorageBufferOffsetsTargets, D::Error&gt;
<span class="kw">where
    </span>D: serde::Deserializer&lt;<span class="lifetime">'de</span>&gt;,
{
    <span class="kw">use </span>serde::Deserialize;

    <span class="kw">let </span>vec = Vec::&lt;DynamicStorageBufferOffsetTargetSerialization&gt;::deserialize(deserializer)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>map = DynamicStorageBufferOffsetsTargets::default();
    <span class="kw">for </span>item <span class="kw">in </span>vec {
        map.insert(item.index, item.bind_target);
    }
    <span class="prelude-val">Ok</span>(map)
}

<span class="kw">pub type </span>DynamicStorageBufferOffsetsTargets = std::collections::BTreeMap&lt;u32, OffsetsBindTarget&gt;;

<span class="doccomment">/// Shorthand result used internally by the backend
</span><span class="kw">type </span>BackendResult = <span class="prelude-ty">Result</span>&lt;(), Error&gt;;

<span class="attr">#[derive(Clone, Debug, PartialEq, thiserror::Error)]
#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
</span><span class="kw">pub enum </span>EntryPointError {
    <span class="attr">#[error(<span class="string">"mapping of {0:?} is missing"</span>)]
    </span>MissingBinding(<span class="kw">crate</span>::ResourceBinding),
}

<span class="doccomment">/// Configuration used in the [`Writer`].
</span><span class="attr">#[derive(Clone, Debug, Hash, PartialEq, Eq)]
#[cfg_attr(feature = <span class="string">"serialize"</span>, derive(serde::Serialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, derive(serde::Deserialize))]
#[cfg_attr(feature = <span class="string">"deserialize"</span>, serde(default))]
</span><span class="kw">pub struct </span>Options {
    <span class="doccomment">/// The hlsl shader model to be used
    </span><span class="kw">pub </span>shader_model: ShaderModel,
    <span class="doccomment">/// Map of resources association to binding locations.
    </span><span class="attr">#[cfg_attr(
        feature = <span class="string">"deserialize"</span>,
        serde(deserialize_with = <span class="string">"deserialize_binding_map"</span>)
    )]
    </span><span class="kw">pub </span>binding_map: BindingMap,
    <span class="doccomment">/// Don't panic on missing bindings, instead generate any HLSL.
    </span><span class="kw">pub </span>fake_missing_bindings: bool,
    <span class="doccomment">/// Add special constants to `SV_VertexIndex` and `SV_InstanceIndex`,
    /// to make them work like in Vulkan/Metal, with help of the host.
    </span><span class="kw">pub </span>special_constants_binding: <span class="prelude-ty">Option</span>&lt;BindTarget&gt;,
    <span class="doccomment">/// Bind target of the push constant buffer
    </span><span class="kw">pub </span>push_constants_target: <span class="prelude-ty">Option</span>&lt;BindTarget&gt;,
    <span class="doccomment">/// Bind target of the sampler heap and comparison sampler heap.
    </span><span class="kw">pub </span>sampler_heap_target: SamplerHeapBindTargets,
    <span class="doccomment">/// Mapping of each bind group's sampler index buffer to a bind target.
    </span><span class="attr">#[cfg_attr(
        feature = <span class="string">"deserialize"</span>,
        serde(deserialize_with = <span class="string">"deserialize_sampler_index_buffer_bindings"</span>)
    )]
    </span><span class="kw">pub </span>sampler_buffer_binding_map: SamplerIndexBufferBindingMap,
    <span class="doccomment">/// Bind target for dynamic storage buffer offsets
    </span><span class="attr">#[cfg_attr(
        feature = <span class="string">"deserialize"</span>,
        serde(deserialize_with = <span class="string">"deserialize_storage_buffer_offsets"</span>)
    )]
    </span><span class="kw">pub </span>dynamic_storage_buffer_offsets_targets: DynamicStorageBufferOffsetsTargets,
    <span class="doccomment">/// Should workgroup variables be zero initialized (by polyfilling)?
    </span><span class="kw">pub </span>zero_initialize_workgroup_memory: bool,
    <span class="doccomment">/// Should we restrict indexing of vectors, matrices and arrays?
    </span><span class="kw">pub </span>restrict_indexing: bool,
    <span class="doccomment">/// If set, loops will have code injected into them, forcing the compiler
    /// to think the number of iterations is bounded.
    </span><span class="kw">pub </span>force_loop_bounding: bool,
}

<span class="kw">impl </span>Default <span class="kw">for </span>Options {
    <span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
        Options {
            shader_model: ShaderModel::V5_1,
            binding_map: BindingMap::default(),
            fake_missing_bindings: <span class="bool-val">true</span>,
            special_constants_binding: <span class="prelude-val">None</span>,
            sampler_heap_target: SamplerHeapBindTargets::default(),
            sampler_buffer_binding_map: std::collections::BTreeMap::default(),
            push_constants_target: <span class="prelude-val">None</span>,
            dynamic_storage_buffer_offsets_targets: std::collections::BTreeMap::new(),
            zero_initialize_workgroup_memory: <span class="bool-val">true</span>,
            restrict_indexing: <span class="bool-val">true</span>,
            force_loop_bounding: <span class="bool-val">true</span>,
        }
    }
}

<span class="kw">impl </span>Options {
    <span class="kw">fn </span>resolve_resource_binding(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        res_binding: <span class="kw-2">&amp;</span><span class="kw">crate</span>::ResourceBinding,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;BindTarget, EntryPointError&gt; {
        <span class="kw">match </span><span class="self">self</span>.binding_map.get(res_binding) {
            <span class="prelude-val">Some</span>(target) =&gt; <span class="prelude-val">Ok</span>(<span class="kw-2">*</span>target),
            <span class="prelude-val">None </span><span class="kw">if </span><span class="self">self</span>.fake_missing_bindings =&gt; <span class="prelude-val">Ok</span>(BindTarget {
                space: res_binding.group <span class="kw">as </span>u8,
                register: res_binding.binding,
                binding_array_size: <span class="prelude-val">None</span>,
                dynamic_storage_buffer_offsets_index: <span class="prelude-val">None</span>,
                restrict_indexing: <span class="bool-val">false</span>,
            }),
            <span class="prelude-val">None </span>=&gt; <span class="prelude-val">Err</span>(EntryPointError::MissingBinding(<span class="kw-2">*</span>res_binding)),
        }
    }
}

<span class="doccomment">/// Reflection info for entry point names.
</span><span class="attr">#[derive(Default)]
</span><span class="kw">pub struct </span>ReflectionInfo {
    <span class="doccomment">/// Mapping of the entry point names.
    ///
    /// Each item in the array corresponds to an entry point index. The real entry point name may be different if one of the
    /// reserved words are used.
    ///
    /// Note: Some entry points may fail translation because of missing bindings.
    </span><span class="kw">pub </span>entry_point_names: Vec&lt;<span class="prelude-ty">Result</span>&lt;String, EntryPointError&gt;&gt;,
}

<span class="attr">#[derive(Error, Debug)]
</span><span class="kw">pub enum </span>Error {
    <span class="attr">#[error(transparent)]
    </span>IoError(<span class="attr">#[from] </span>FmtError),
    <span class="attr">#[error(<span class="string">"A scalar with an unsupported width was requested: {0:?}"</span>)]
    </span>UnsupportedScalar(<span class="kw">crate</span>::Scalar),
    <span class="attr">#[error(<span class="string">"{0}"</span>)]
    </span>Unimplemented(String), <span class="comment">// TODO: Error used only during development
    </span><span class="attr">#[error(<span class="string">"{0}"</span>)]
    </span>Custom(String),
    <span class="attr">#[error(<span class="string">"overrides should not be present at this stage"</span>)]
    </span>Override,
}

<span class="attr">#[derive(PartialEq, Eq, Hash)]
</span><span class="kw">enum </span>WrappedType {
    ZeroValue(help::WrappedZeroValue),
    ArrayLength(help::WrappedArrayLength),
    ImageQuery(help::WrappedImageQuery),
    ImageLoadScalar(<span class="kw">crate</span>::Scalar),
    Constructor(help::WrappedConstructor),
    StructMatrixAccess(help::WrappedStructMatrixAccess),
    MatCx2(help::WrappedMatCx2),
    Math(help::WrappedMath),
    UnaryOp(help::WrappedUnaryOp),
    BinaryOp(help::WrappedBinaryOp),
}

<span class="attr">#[derive(Default)]
</span><span class="kw">struct </span>Wrapped {
    types: <span class="kw">crate</span>::FastHashSet&lt;WrappedType&gt;,
    <span class="doccomment">/// If true, the sampler heaps have been written out.
    </span>sampler_heaps: bool,
    <span class="comment">// Mapping from SamplerIndexBufferKey to the name the namer returned.
    </span>sampler_index_buffers: <span class="kw">crate</span>::FastHashMap&lt;SamplerIndexBufferKey, String&gt;,
}

<span class="kw">impl </span>Wrapped {
    <span class="kw">fn </span>insert(<span class="kw-2">&amp;mut </span><span class="self">self</span>, r#type: WrappedType) -&gt; bool {
        <span class="self">self</span>.types.insert(r#type)
    }

    <span class="kw">fn </span>clear(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="self">self</span>.types.clear();
    }
}

<span class="doccomment">/// A fragment entry point to be considered when generating HLSL for the output interface of vertex
/// entry points.
///
/// This is provided as an optional parameter to [`Writer::write`].
///
/// If this is provided, vertex outputs will be removed if they are not inputs of this fragment
/// entry point. This is necessary for generating correct HLSL when some of the vertex shader
/// outputs are not consumed by the fragment shader.
</span><span class="kw">pub struct </span>FragmentEntryPoint&lt;<span class="lifetime">'a</span>&gt; {
    module: <span class="kw-2">&amp;</span><span class="lifetime">'a </span><span class="kw">crate</span>::Module,
    func: <span class="kw-2">&amp;</span><span class="lifetime">'a </span><span class="kw">crate</span>::Function,
}

<span class="kw">impl</span>&lt;<span class="lifetime">'a</span>&gt; FragmentEntryPoint&lt;<span class="lifetime">'a</span>&gt; {
    <span class="doccomment">/// Returns `None` if the entry point with the provided name can't be found or isn't a fragment
    /// entry point.
    </span><span class="kw">pub fn </span>new(module: <span class="kw-2">&amp;</span><span class="lifetime">'a </span><span class="kw">crate</span>::Module, ep_name: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>str) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="self">Self</span>&gt; {
        module
            .entry_points
            .iter()
            .find(|ep| ep.name == ep_name)
            .filter(|ep| ep.stage == <span class="kw">crate</span>::ShaderStage::Fragment)
            .map(|ep| <span class="self">Self </span>{
                module,
                func: <span class="kw-2">&amp;</span>ep.function,
            })
    }
}

<span class="kw">pub struct </span>Writer&lt;<span class="lifetime">'a</span>, W&gt; {
    out: W,
    names: <span class="kw">crate</span>::FastHashMap&lt;proc::NameKey, String&gt;,
    namer: proc::Namer,
    <span class="doccomment">/// HLSL backend options
    </span>options: <span class="kw-2">&amp;</span><span class="lifetime">'a </span>Options,
    <span class="doccomment">/// Information about entry point arguments and result types.
    </span>entry_point_io: Vec&lt;writer::EntryPointInterface&gt;,
    <span class="doccomment">/// Set of expressions that have associated temporary variables
    </span>named_expressions: <span class="kw">crate</span>::NamedExpressions,
    wrapped: Wrapped,
    written_committed_intersection: bool,
    written_candidate_intersection: bool,
    continue_ctx: back::continue_forward::ContinueCtx,

    <span class="doccomment">/// A reference to some part of a global variable, lowered to a series of
    /// byte offset calculations.
    ///
    /// See the [`storage`] module for background on why we need this.
    ///
    /// Each [`SubAccess`] in the vector is a lowering of some [`Access`] or
    /// [`AccessIndex`] expression to the level of byte strides and offsets. See
    /// [`SubAccess`] for details.
    ///
    /// This field is a member of [`Writer`] solely to allow re-use of
    /// the `Vec`'s dynamic allocation. The value is no longer needed
    /// once HLSL for the access has been generated.
    ///
    /// [`Storage`]: crate::AddressSpace::Storage
    /// [`SubAccess`]: storage::SubAccess
    /// [`Access`]: crate::Expression::Access
    /// [`AccessIndex`]: crate::Expression::AccessIndex
    </span>temp_access_chain: Vec&lt;storage::SubAccess&gt;,
    need_bake_expressions: back::NeedBakeExpressions,
}
</code></pre></div></section></main></body></html>